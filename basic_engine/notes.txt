Goal: Generic ObjectOriented Game Enigne

Edge cases:
    pawn, en passant
    castling
    
Other weird things: 
    pawn-promotion
    king must move out of check
    king cannot move into check
    other peices can't move in a way that puts king in check

figure out inheritance of a king(piece)

1/17

store board position with 1=white vs 2=black

two_by_ones()

try filtering pieces by b_white property

get_available_moves()
    eliminate own piece blocks
    allow opponent piece capture

1/18

x  spaces = X is not implemented -> king is not implemented
   pawn move is not implemented
    upacross(spaces = 2, only_up = True)

   filter_blocking can give all the available from all possible
x  filter_by_blocking()

1/19


finish implementing all piece movements

make a turn-engine
    x make random moves
    x allow input to control a player

king and enpassant-vulnerable-pawn are needed as enums on board

Long-Term:
    calculate all get_diags get_across etc for each position into a lookup table
    can cache available moves to each piece and use in next turn


why does the debug break in VScode on print IOError?
    > print rook_moves
    > IOError: [Errno 2] No such file or directory
    everyone since Fall Creator updates has this:
        https://github.com/Microsoft/vscode/issues/36630

board should store edge cases:
     king_can_castle, rook_can_castle, en_passant_vulnerable [0,1,,0,0]...

    -> so that, piece.get_available_moves(board) is full evaulation
       not: piece.get_available_moves(board, white's pawns, etc...)

1/22

    todo:
        en passant
        castling
        player move cant put his king in check
        
        promotion
        available_moves when player in check
        >hint should display moves helpfully

    BUT: the below doesnt work becaused it has to occur for each-piece-move tuple
        same as iterating of opponent's possible moves. Instead we need a 
        list of positions on the board that help keep king out of check for non-king moves
        these dont include horse moves because horse is never blocked.
        Only when one of these pieces is proposed moved could the king be threatened.
        Note: this only occurs when a piece MOVES AWAY, not where it moves TO.
        This set of own-players pieces, calcd before each turn, is what hypo-king
        helps us calculate.

    it will be a lot faster to model is_king_in_check 
    without iterating across all opponents pieces possible moves 
    which runs in  O(piece-moves^2) or O(piece-moves * 2) (?)
    instead create a King-Hypothetical class which has all other pieces'
    moves and see if it "can kill" an opponents piece of the class that
    has the move type, which should be on the order of O(piece-move) 
    little higher than Queen's O(piece-move).
    You might also be able to cache the result, and only recalculate
    if a certain piece "assuring" it remains in position is moved.

    you can test the bigO-time by changing BOARD_WIDTH = 9,10,11,...
    you can test practical perf by taking random moves, or importing
    saved chess games and running total time it takes to calc all
    get_available_moves() using each method

Takeaways:

    the correct level of abstraction for the Board is 
        piece vs. blank, 
        white-piece vs black-piece
        special-piece vs generic-piece. specials:
            king
            en-passant-vulnerable-pawn 
        ...nothing else needs to be considered at game-logic level, only
           further up at the stratgey-level.

    

    A board-move class holds dimensions of the board, the coloring and orietation, and
    the rules for the initial piece setup.
    Also, it holds the mathematical logic of the atomic moves:
        upacross [distance modifier] [w/wo player-direction-orientation e.g what is "move up"]
        diagonal [distance modifier] [w/wo player-direction-orientation]
        two_by_one
        

    The pieces then hold the business rules for which atomic move types they can perform and
    at what modification they can perform them, plus GameLedger modifications

        in addition to the Board is a Game-Ledger which tracks
            [king_can_castle | rook_can_castle]
            king_in_check
            turn_counter_while_solitary_king
            last_two_moves_tracker (for a 3-move-repeat-stalemate)
            pawn_advance_two can be held in the piece object

    Most rules are packed into available_moves routine
    
    Available_Moves_Player_P <- func(Board,Pieces,GameLedger)
        Available_Moves_i <- func(Piece_i,Board_current)
            <- filtered(king in check) Func(Board, Pieces)
               if GameLedger.check_flag
                    <- filtered(move-removes-check_flag)

    Then the strategy-module needs to consider the following info-blobs:
        Game board with pieces
        GameLedger
        Player_turn_current
        [turn_counter ?]
        ... everything else is derivative?
        
random thought: a mechanichal chess board is valuable to new variants of the rules that need
                inter-turn reshuffling of the pieces of display of available moves

        


