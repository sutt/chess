Goal: Generic ObjectOriented Game Enigne

Edge cases:
    pawn, en passant
    castling
    
Other weird things: 
    pawn-promotion
    king must move out of check
    king cannot move into check
    other peices can't move in a way that puts king in check

figure out inheritance of a king(piece)

1/17

store board position with 1=white vs 2=black

two_by_ones()

try filtering pieces by b_white property

get_available_moves()
    eliminate own piece blocks
    allow opponent piece capture

1/18

x  spaces = X is not implemented -> king is not implemented
   pawn move is not implemented
    upacross(spaces = 2, only_up = True)

   filter_blocking can give all the available from all possible
x  filter_by_blocking()

1/19


finish implementing all piece movements

make a turn-engine
    x make random moves
    x allow input to control a player

king and enpassant-vulnerable-pawn are needed as enums on board

Long-Term:
    calculate all get_diags get_across etc for each position into a lookup table
    can cache available moves to each piece and use in next turn


why does the debug break in VScode on print IOError?
    > print rook_moves
    > IOError: [Errno 2] No such file or directory
    everyone since Fall Creator updates has this:
        https://github.com/Microsoft/vscode/issues/36630

board should store edge cases:
     king_can_castle, rook_can_castle, en_passant_vulnerable [0,1,,0,0]...

    -> so that, piece.get_available_moves(board) is full evaulation
       not: piece.get_available_moves(board, white's pawns, etc...)

1/22

    todo:
        en passant
        castling
        player move cant put his king in check
        
        promotion
        available_moves when player in check
        >hint should display moves helpfully

1/23

    need to clear en passant
    write tests for enpassant in main
    castling
    pretty-print available moves

1/26

    tests for castling
    clear_castling
    bug for calling a castle ambiguous with king step left
    bug for both castles being available when one is False, the "any()" line is culprit?
    tests for clear castling
    test for main() by loading moves
    tests for castling

1/27

    x modfiy_castle()
    x test this out
    add tests to main 
        add instructions in Select A Move section
        add 

    Takeaways: data_struct[player] vs data_struct[1-int(player)]
    is a very easy mistake to make and shows why you need getter'instead
    of modifying the property "by hand".


1/28

    as i realized, checkmate detector is not difficult, it is only:
        -available_moves [where king not in check] = {} ("empty set")
        -check_flag = True
    -> so the real heart of the game is calc'ing is_king_in_check

    modular idea: what if board.data was a numpy array? smaller mem and faster?

    #NOTE - how to get out of check? all moves filtered by king_in_check
            #   but how to handle killing the checking piece?

    TODO:
        refactor data_by_player
    x    add named_tuple for move
        make player 0,1 not true,False
        make board the first argument in TurnStage functions

1/29

    TODO:
        add to Game() init_board, init_player 
           to allow testing specific situations

        add exit code for available moves
        add exit code for total number of moves to allow random play

        build tests for king in check in specific situations

        add perf_test.py to time play()

            add a bool to game to turn on/off filter_king_check()
            check the difference in time

            add perf_test_log to GameLog to collect granular timing
               data and additional info at each step

        build analyze_perf_test to analyze num_moves vs time_compute, etc.

    Ahh so optimal is O(n) * c where c is in [1,4]

    there are multiple optimizations:
        
        instead of copying the board, just set different positions,
        and then set them back as you exit function. (or is that even needed?) 
            (this could be wrong for en passant situations, 
                so dont run this optimize if this is so )

        how about "piping" moves from get_available -> filter_check
            this involves async in py3?

        using numpy instead of list of list
        using a 64char string instead of a list

        using superking instead of all opponent's pieces

        pre-computation+lookup for piece.get_moves() instead of on-the-spot calc

    so the initial abstraction of piece kills opponents piece regardless of rank
    breaks down here, as the king is special. we already knew that with check_flag 
    but that is poor because a. it's arduous to compute move_yourself_into_check 
    in O(n^2) and b. it doesnt capture the idea of moving so as to place opponent 
    in check.

    Ah, but none of the atomic-moves overlap thus the move_type and move can be parsed
    after exiting blocking_piece() at the bottom of get_available()

    Playful aside: like in poker with 'Hand' as a concept, 'check' is an ambiguous
    and overused concept in chess.

    TODO

        add board.get_pos_value(pos) and refactor
        add put_in_check also using mirror
        write non encapsulated
        apply yield in select spots
        create a modularized perf_test
        add more insturctions to see larger n
        build a n_available_moves log into GameLog and record during perf_test
        how to do reflective class.getattr()
            -> if so get to class_move_types in one calc?
            should be named piece_movetypes_spaces

    1/31

        investigate pieces.pop() issue?
        

    a better name for super-king is mirror-piece: "if it can kill you, you can kill it"
    or an anti-king: "can attack only when in check"
        this is like a queen plus a horse but can't kill pawns head-on
        and cant kill king except directly adjacent
        but it doesn't neccesarily move unless attacking.
        ahh but what if oppoent piece cant kill it because doing so would put 
        himself in check? can the mirror-piece still attack opponent, except with king
        where he cant kill it because that would put him in check
        

    2/8

    TODO

        x PoC with turn_times in perf_test
        x basic check_optimal implementation
        copy.deepcopy on get_log_X() as they are list of lists
        x perf_test of using bypass mirror calc in possible_check_optimal() 
        tests to figure out if optimal works for all cases naive does
        does check_optimal work with pawns? prolly not right now

        think about how to mutate board instead of apply_rule
            do you need pos0? or pos1?
            do you need to account for kill_piece popping? - (yes)
            and how does this change in check_opponent vs 
                dont_move_self_into_check

            so i think you need pos0 only on dont_move_self_into_check,
                (for everything execpt castling, and king moves)
                but you need pos1 only on opponent_check. True?

            so essentially if MOVE_CODE == 'regular' then do mirror, 
            otherwise do naive could work

        how do you isolate get_available_moves() time from full turn loop?

        Try @classmethod
        https://julien.danjou.info/blog/2013/guide-python-static-class-abstract-methods

    2/9

        x Print out turn_time
        try to remove copy(board) from inner loop
        do a plt
        do a regression
        first we need more game-data, need a save function from manual mode
        need a way to return game state data in  board, like in-check to tests

        BUGS
            moving R or K after castling does not work
            filter_copy_apply_4 is fast but doesnt pass 3 test
        
    Takeaway 1/30

        check out Mirror class for a pattern for building up a list of 
        increasingly large and informative tuples. But could this be accomplished
        in the other direction for each move, go through all the steps...?

        can't you just build list<-map() for each step      

        overall, a pretty good way to build 'a mirror image piece in OO chess engine'
        but YMMV. why:

            - encapsulation of functions, even staticmoves dont crowd into other modules

            - it represents one esoteric, isolated, confusing concept - that these 
            three pieces of information - move_type, move_paces, piece_class - can
            allow you to deduce if king is in check (or any piece in general is threatend)
            and this doesnt get applied or depended on anywhere else.            

            - it allows you to build up a naming motif in a completely enclosed scope

            - it allows you to build up a processing motif e.g 
              self.var2 = [func(x) for x in self.var]

            - shows you clearly what are inputs and outputs to this processing, and if
              any special order is needed

            - modularizes comments to its atomic concern: you can't about Hypothetical
              code changes that might affect this instruction while proc procedurally




    

    Idea for perf analysis:

    BUT: the below doesnt work becaused it has to occur for each-piece-move tuple
        same as iterating of opponent's possible moves. Instead we need a 
        list of positions on the board that help keep king out of check for non-king moves
        these dont include horse moves because horse is never blocked.
        Only when one of these pieces is proposed moved could the king be threatened.
        Note: this only occurs when a piece MOVES AWAY, not where it moves TO.
        This set of own-players pieces, calcd before each turn, is what hypo-king
        helps us calculate.

    it will be a lot faster to model is_king_in_check 
    without iterating across all opponents pieces possible moves 
    which runs in  O(piece-moves^2) or O(piece-moves * 2) (?)
    instead create a King-Hypothetical class which has all other pieces'
    moves and see if it "can kill" an opponents piece of the class that
    has the move type, which should be on the order of O(piece-move) 
    little higher than Queen's O(piece-move).
    You might also be able to cache the result, and only recalculate
    if a certain piece "assuring" it remains in position is moved.

    you can test the bigO-time by changing BOARD_WIDTH = 9,10,11,...
    you can test practical perf by taking random moves, or importing
    saved chess games and running total time it takes to calc all
    get_available_moves() using each method

    1/27 Thoughts:
        - it is O(n^2) if you think of piece-moves, and the most naive algo
         - to make the board wider, you need to handle castling better with board_width param

Takeaways:

    1/27
    software engineering and team-code practices become important at the point where
    one nice abstraction no longer encapsulates the whole requirements: in this case
    that occurs when enpassant and castling are added in. This requires enums and if/then
    logic processing

    Also, its true that available_moves, followed by end-game-conditions-check
    is the how to write these engines.

    instantiating the pieces is costly at each branch

    the correct level of abstraction for the Board is 
        piece vs. blank, 
        white-piece vs black-piece
        special-piece vs generic-piece. specials:
            king
            en-passant-vulnerable-pawn 
        ...nothing else needs to be considered at game-logic level, only
           further up at the stratgey-level.

    

    A board-move class holds dimensions of the board, the coloring and orietation, and
    the rules for the initial piece setup.
    Also, it holds the mathematical logic of the atomic moves:
        upacross [distance modifier] [w/wo player-direction-orientation e.g what is "move up"]
        diagonal [distance modifier] [w/wo player-direction-orientation]
        two_by_one
        

    The pieces then hold the business rules for which atomic move types they can perform and
    at what modification they can perform them, plus GameLedger modifications

        in addition to the Board is a Game-Ledger which tracks
            [king_can_castle | rook_can_castle]
            king_in_check
            turn_counter_while_solitary_king
            last_two_moves_tracker (for a 3-move-repeat-stalemate)
            pawn_advance_two can be held in the piece object

    Most rules are packed into available_moves routine
    
    Available_Moves_Player_P <- func(Board,Pieces,GameLedger)
        Available_Moves_i <- func(Piece_i,Board_current)
            <- filtered(king in check) Func(Board, Pieces)
               if GameLedger.check_flag
                    <- filtered(move-removes-check_flag)

    Then the strategy-module needs to consider the following info-blobs:
        Game board with pieces
        GameLedger
        Player_turn_current
        [turn_counter ?]
        ... everything else is derivative?
        
random thought: a mechanichal chess board is valuable to new variants of the rules that need
                inter-turn reshuffling of the pieces of display of available moves

        


