Goal: Generic ObjectOriented Game Enigne

Edge cases:
    pawn, en passant
    castling
    
Other weird things: 
    pawn-promotion
    king must move out of check
    king cannot move into check
    other peices can't move in a way that puts king in check

figure out inheritance of a king(piece)

1/17

store board position with 1=white vs 2=black

two_by_ones()

try filtering pieces by b_white property

get_available_moves()
    eliminate own piece blocks
    allow opponent piece capture

1/18

x  spaces = X is not implemented -> king is not implemented
   pawn move is not implemented
    upacross(spaces = 2, only_up = True)

   filter_blocking can give all the available from all possible
x  filter_by_blocking()

1/19


finish implementing all piece movements

make a turn-engine


    x make random moves

    x allow input to control a player


  

king and enpassant-vulnerable-pawn are needed as enums on board

Long-Term:
    calculate all get_diags get_across etc for each position into a lookup table
    can cache available moves to each piece and use in next turn




why does the debug break in VScode on print IOError?
    > print rook_moves
    > IOError: [Errno 2] No such file or directory
    everyone since Fall Creator updates has this:
        https://github.com/Microsoft/vscode/issues/36630

board should store edge cases:
     king_can_castle, rook_can_castle, en_passant_vulnerable [0,1,,0,0]...

    -> so that, piece.get_available_moves(board) is full evaulation
       not: piece.get_available_moves(board, white's pawns, etc...)

1/22

    todo:
        en passant
        castling
        player move cant put his king in check
        
        promotion
        available_moves when player in check
        >hint should display moves helpfully

        it will be a lot faster to model is_king_in_check 
        without iterating across all opponents pieces possible moves 
        which runs in O(piece-moves^2)
        instead create a King-Hypothetical class which has all other pieces'
        moves and see if it "can kill" an opponents piece of the class that
        has the move type, which should be on the order of O(piece-move) 
        little higher than Queen's O(piece-move).
        You might also be able to cache the result, and only recalculate
        if a certain piece "assuring" it remains in position

Takeaways:

    the correct level of abstraction for the Board is 
        piece vs. blank, 
        white-piece vs black-piece
        special-piece vs generic-piece. specials:
            king
            en-passant-vulnerable-pawn 
        ...nothing else needs to be considered at game-logic level, only
           further up at the stratgey-level.

    

    A board-move class holds dimensions of the board, the coloring and orietation, and
    the rules for the initial piece setup.
    Also, it holds the mathematical logic of the atomic moves:
        upacross [distance modifier] [w/wo player-direction-orientation e.g what is "move up"]
        diagonal [distance modifier] [w/wo player-direction-orientation]
        two_by_one
        

    The pieces then hold the business rules for which atomic move types they can perform and
    at what modification they can perform them, plus GameLedger modifications

        in addition to the Board is a Game-Ledger which tracks
            [king_can_castle | rook_can_castle]
            king_in_check
            turn_counter_while_solitary_king
            last_two_moves_tracker (for a 3-move-repeat-stalemate)
            pawn_advance_two can be held in the piece object

    Most rules are packed into available_moves routine
    
    Available_Moves_Player_P <- func(Board,Pieces,GameLedger)
        Available_Moves_i <- func(Piece_i,Board_current)
            <- filtered(king in check) Func(Board, Pieces)
               if GameLedger.check_flag
                    <- filtered(move-removes-check_flag)

    Then the strategy-module needs to consider the following info-blobs:
        Game board with pieces
        GameLedger
        Player_turn_current
        [turn_counter ?]
        ... everything else is derivative?
        
random thought: a mechanichal chess board is valuable to new variants of the rules that need
                inter-turn reshuffling of the pieces of display of available moves

        


